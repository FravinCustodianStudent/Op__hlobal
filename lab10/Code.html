<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="">
  <meta property="og:type" content="">
  <meta property="og:url" content="">
  <meta property="og:image" content="">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css">
  <link rel="manifest" href="site.webmanifest">
  <link rel="apple-touch-icon" href="icon.png">
  <!-- Place favicon.ico in the root directory -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/normalize.css">
  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/menu.css">
  <link href="../css/hover.css" rel="stylesheet" media="all">
  <link href="Lab.css" rel="stylesheet">
  <link rel='stylesheet' href='../box-shadows.css'>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
  />
  <meta name="theme-color" content="#fafafa">
</head>
<script src="../js/main.js"></script>
<body>
<div class="circlegradient" id="firstcircle"></div>
<div class="circlegradient" id="secondcircle"></div>
<div class="menu_g">
  <div class="menu_u">
    <map class="aa"><a href="../menu.html"><div class="gradieninputsqz hvr-grow" >
      <img src="../img/menu.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Меню</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href="purpose.html"><div class="gradieninputsqz hvr-grow" >
      <img src="../img/target.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Мета Роботи</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href="task3.html"><div class="gradieninputsqz hvr-grow" >
      <img src="../img/audit.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Умова задачі</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=Analize.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/search.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Аналіз задачі</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=Blockscheme.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/block-scheme-of-geometrical-shapes.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Блок-схема</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=Code.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/programming-code-signs.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Код програми</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=result.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/check-mark.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Результат<br>виконання </h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=proof.html> <div class="gradieninputsqz hvr-grow" >
      <img src="../img/approve.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Аналіз достовірності</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=conclusion.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/finalq.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Висновки</h2></div>
  </div>




</div>
<div class="mblock" id="generalqzzzz">
  <h1 id="maintextqqq">Код програми</h1>
  <div id="gradieninputsq" >
    <img src="../img/programming-code-signs.png" class="manuelement"></div>
  <div class="line" id="firstlineqq"></div>
  <div id="purposetext">
  <div class="container">
    <p class="language">C++</p>
    <div class="code-wrapper">
      <pre>
        <code id="code">
#include < iostream>
#include< iomanip>
using namespace std;

class MyString
{
public:

	//конструктор без парамтрів
	MyString()
	{
		str = nullptr;
		length = 0;
	}

	//конструктор з параметрами, під час створення об'єкта класу необхідно переробити рядок який він зберігатиме
	MyString(const char* str)
	{

		length = strlen(str);// функція strlen отримує кількість символів у рядку, який ми передаємо в об'єкт

		//виділяємо пам'ять для динамічного масиву де зберігатиметься наш рядок
		this->str = new char[length + 1];

		//копіюємо символи рядка до масиву нашого класу
		for (int i = 0; i < length; i++)
		{
			this->str[i] = str[i];
		}


		//закриваємо рядок термінуючим нулем
		this->str[length] = '\0';

	}
	// Деструктор, що відповідає за звільнення ресурсів зайнятих об'єктом, викликається при знищенні об'єкта класу
	~MyString()
	{

		delete[] this->str;
	}

	// Конструктор копіювання, необхідний для створення точної копії об'єкта класу, але в іншій області пам'яті
	MyString(const MyString& other)
	{
		length = strlen(other.str);
		this->str = new char[length + 1];

		for (int i = 0; i < length; i++)
		{
			this->str[i] = other.str[i];
		}

		this->str[length] = '\0';
	}

	// перезавантажений оператор привласнення, що викликається коли необхідно присвоїти значення одного об'єкта іншому
	MyString& operator =(const MyString& other)
	{
		if (this->str != nullptr)
		{
			delete[] str;
		}

		length = strlen(other.str);
		this->str = new char[length + 1];

		for (int i = 0; i < length; i++)
		{
			this->str[i] = other.str[i];
		}

		this->str[length] = '\0';

		return *this;

	}

	//перезавантажений оператор складання, у поточній реалізації класу String необхідний для конкатенації рядків
	MyString operator+(const MyString& other)
	{
		MyString newStr;

		int thisLength = strlen(this->str);
		int otherLength = strlen(other.str);

		newStr.length = thisLength + otherLength;

		newStr.str = new char[thisLength + otherLength + 1];

		int i = 0;
		for (; i < thisLength; i++)
		{
			newStr.str[i] = this->str[i];
		}

		for (int j = 0; j < otherLength; j++, i++)
		{
			newStr.str[i] = other.str[j];
		}

		newStr.str[thisLength + otherLength] = '\0';

		return newStr;
	}
	MyString operator<<(const MyString& other) {
		cout << other.str;
	}
	void Print()
	{
		cout << str;
	}

	int Length()
	{
		return length;
	}

	bool operator ==(const MyString& other)
	{
		if (this->length != other.length)
		{
			return false;
		}

		for (int i = 0; i < this->length; i++)
		{
			if (this->str[i] != other.str[i])
			{
				return false;
			}
		}
		return true;
	}

	bool operator !=(const MyString& other)
	{
		return !(this->operator==(other));
	}

	char& operator [](int index)
	{
		return this->str[index];
	}

	MyString(MyString&& other)
	{
		this->length = other.length;
		this->str = other.str;
		other.str = nullptr;
	}

private:
	char* str;
	int length;
};



void Print_(const int& amount);
float NumberInput();
enum Choice {
	First = 1,
	Second = 2,
	Third = 3,
	Fourth = 4,
	Fifth = 5,
	EndStatus = 222
};

Choice choice;
template< typename T>
class List
{
public:
	List();
	~List();

	//удаление первого элемента в списке
	void pop_front();

	//добавление элемента в конец списка
	void push_back(T data);

	// очистить список
	void clear();

	// получить количество елементов в списке
	int GetSize() { return Size; }

	// перегруженный оператор []
	T& operator[](const int index);

	//добавление элемента в начало списка
	void push_front(T data);

	//добавление элемента в список по указанному индексу
	void insert(T data, int index);

	//удаление элемента в списке по указанному индексу
	void removeAt(int index);

	//удаление последнего элемента в списке
	void pop_back();

private:


	template< typename T>
	class Node
	{
	public:
		Node* pNext;
		T data;

		Node(T data = T(), Node* pNext = nullptr)
		{
			this->data = data;
			this->pNext = pNext;
		}
	};
	int Size;
	Node< T>* head;
};


template< typename T>
List< T>::List()
{
	Size = 0;
	head = nullptr;
}


template< typename T>
List< T>::~List()
{
	clear();
}


template< typename T>
void List< T>::pop_front()
{
	Node< T>* temp = head;

	head = head->pNext;

	delete temp;

	Size--;

}

template< typename T>
void List< T>::push_back(T data)
{
	if (head == nullptr)
	{
		head = new Node< T>(data);
	}
	else
	{
		Node< T>* current = this->head;

		while (current->pNext != nullptr)
		{
			current = current->pNext;
		}
		current->pNext = new Node< T>(data);

	}

	Size++;
}

template< typename T>
void List< T>::clear()
{
	while (Size)
	{
		pop_front();
	}
}


template< typename T>
T& List< T>::operator[](const int index)
{
	int counter = 0;

	Node< T>* current = this->head;

	while (current != nullptr)
	{
		if (counter == index)
		{
			return current->data;
		}
		current = current->pNext;
		counter++;
	}
}

template< typename T>
void List< T>::push_front(T data)
{
	head = new Node< T>(data, head);
	Size++;
}

template< typename T>
void List< T>::insert(T data, int index)
{

	if (index == 0)
	{
		push_front(data);
	}
	else
	{
		Node< T>* previous = this->head;

		for (int i = 0; i < index - 1; i++)
		{
			previous = previous->pNext;
		}

		Node< T>* newNode = new Node< T>(data, previous->pNext);

		previous->pNext = newNode;

		Size++;
	}





}

template< typename T>
void List< T>::removeAt(int index)
{
	if (index == 0)
	{
		pop_front();
	}
	else
	{
		Node< T>* previous = this->head;
		for (int i = 0; i < index - 1; i++)
		{
			previous = previous->pNext;
		}


		Node< T>* toDelete = previous->pNext;

		previous->pNext = toDelete->pNext;

		delete toDelete;

		Size--;
	}

}

template< typename T>
void List< T>::pop_back()
{
	removeAt(Size - 1);
}

struct Student {
	enum Faculty
	{
		NFaculty=0,
		FIT = 1,
		Cybernetic = 2

	};
	MyString name;
	int stipedndia;
	int mark;
	Faculty faculty;
	int cource;
	int group;
	Student() {
		this->mark = NULL;
		this->faculty = NFaculty;
		this->stipedndia = NULL;
		this->cource = NULL;
		this->group = NULL;
	}
	Student(MyString name, int mark, int choice,int cource,int group) {
		this->name = name;
		this->mark = mark;
		this->stipedndia = NULL;
		this->cource = cource;
		this->group = group;
		this->faculty = static_cast< Faculty>(choice);

	}
	Student(MyString name, int mark, int stipendia, int choice, int cource, int group) :Student(name, mark, choice,cource,group) {
		this->stipedndia = stipendia;
	}
	void Show_info() {
		cout << "|Name: " << setw(5);
		name.Print();
		cout << setw(8) << " |Mark:" << setw(5) << mark << setw(5) << setw(5) << " |Cource " << cource << setw(5) << " |Group " << group << " |Faculty: " << setw(9);
		if (faculty ==FIT)
		{
			cout << "FIT        " << setw(9);
		}
		else {
			cout << "Cybernetic " << setw(9);
		}

		cout<<"|Stypendia: " << setw(5) << stipedndia << " |" << endl;
	}
};
void task1(List< Student>& Group) {
	Print_(60);
	float averageMark = 0;
	float AmountOfStudentWithStipendia = 0;
	for (size_t i = 0; i < Group.GetSize(); i++)
	{

		if (Group[i].stipedndia!=NULL)
		{
			Group[i].Show_info();
			AmountOfStudentWithStipendia++;
			averageMark += Group[i].mark;
		}
	}
	cout << "Averege mark: " << averageMark / AmountOfStudentWithStipendia << endl;
	Print_(60);
}
void task2(List< Student>& Group) {
	Print_(60);
	int FitProblems = 0, CyberneticProbelems=0;
	for (size_t i = 0; i < Group.GetSize(); i++)
	{
		if (Group[i].mark==2 && Group[i].faculty==1)
		{
			FitProblems++;
		}
		else if (Group[i].mark == 2 && Group[i].faculty == 2)
		{
			CyberneticProbelems++;
		}
	}
	cout << "FIT = " << FitProblems << endl;
	cout << "Cybernetic = " << CyberneticProbelems << endl;
	if (FitProblems> CyberneticProbelems)
	{
		cout << "Cybernetic has less flunkey than FIT" << endl;
	}
	else {
		cout << "FIT has less flunkeys than Cybernetic" << endl;
	}
	Print_(60);
}
void task3(List< Student>& Group){
	Print_(60);
	int FITAchivments = 0, CyberneticAchivments = 0;
	for (size_t i = 0; i < Group.GetSize(); i++)
	{
		if (Group[i].mark == 5 && Group[i].faculty == 1)
		{
			FITAchivments++;
		}
		else if (Group[i].mark == 5 && Group[i].faculty == 2)
		{
			CyberneticAchivments++;
		}
	}
	cout << "FIT = " << FITAchivments << endl;
	cout << "Cybernetic = " << CyberneticAchivments << endl;
	if (FITAchivments > CyberneticAchivments)
	{
		cout << "FIT has more excellent student than Cybernetic" << endl;
	}
	else {
		cout << "Cybernetic has more excellent student than FIT" << endl;
	}
	Print_(60);
}
int main()
{

	srand(time(NULL));
	List< Student> Group;
	List< MyString> Names;
	Names.push_back("     Ivan");
	Names.push_back("  Rodslav");
	Names.push_back("Volodimir");
	Names.push_back("   Albert");
	Names.push_back("   Arthur");
	Names.push_back("  Vilgeim");
	Names.push_back("      Ada");
	Names.push_back("    Pavlo");
	Names.push_back("    Magda");
	Names.push_back("   Darina");
	Names.push_back("    Julia");
	Names.push_back("   Ustina");
	srand(time(NULL));
	for (int i1 = 1; i1 < 3; i1++)
	{
			for (int i2 = 1; i2 < 5; i2++)
			{
				for (int i = 1; i < 5; i++)
				{
					for (int i = 0; i < 4; i++)
					{
						int chance_on_stypendia = rand() % 100;
						if (chance_on_stypendia < 50)
						{
							int mark, stipendia;
							int name;
							mark = 4+ rand() %  2;
							name = rand() % 11;
							stipendia = rand() % 200 + 50;

							MyString nameofst = Names[name];
							Student withsipendia = { nameofst,mark,stipendia,i1,i2,i };
							Group.push_back(withsipendia);
						}
						else {
							int mark;
							int name;
							mark = 2 + rand() %  2;
							name = rand() % 11;
							MyString nameofst = Names[name];
							Student withoutStipendia = { nameofst,mark,i1,i2,i };
							Group.push_back(withoutStipendia);
						}

					}
				}

		}
	}
	/*for (int i = 0; i < Group.GetSize();i++)
	{
		Group[i].Show_info();
	}*/
	int Ch;
	std::cout << "\n----START----\nLab 10. Var23. Student Fesak Andrii IPZ-12\nWelcome to see recurent function in C++\n--------" << std::endl;
	//Логічно, що програма повинна виконуватись поки користувач цього хоче тому while(true)
	while (true) {
		Print_(60);
		std::cout << "\nSelect item by press (1)(2) on your keyboard:\n1. Student with scholarship\n2.Faculty with the less amount of flunkeys \n3.Faculty with the best study level\nAnything else. - Exit" << endl;
		Print_(60);
		Ch = NumberInput();
		choice = static_cast< Choice>(Ch);
		switch (choice) {
		case First:
			system("cls");
			task1(Group);
			break;
		case Second:
			system("cls");
			task2(Group);
			break;
		case Third:
		system("cls");
		task3(Group);
		break;
		default:
			//Потрібен метод виходу з програми
			std::cout << "\nDo you want to continue?\n1 - No\nAnything else - Yes\nYour answer: ";
			std::cin >> Ch;
			choice = static_cast< Choice>(Ch);
			if (choice == First)
			{
				choice = EndStatus;
			}
			break;
		}
		//Потрібен метод виходу з програми
		if (choice == EndStatus) break;
	}
}
//Нам пртрібен алгоритм зручної перевіри на число, тобто ця функція перевіряє, чи ввів користувач число
float NumberInput() {
	float x;
	while (!(std::cin >> x)) {
		std::cout << "Some of inputs were wrong, try again\n";
		std::cin.clear();
		fflush(stdin);
		std::cin.ignore(std::numeric_limits< std::streamsize>::max(), '\n');
	}
	return x;
}
void Print_(const int& amount) {
	for (int i = 0; i < amount; i++)
	{
		std::cout << "_";
	}
	std::cout << "\n" << endl;
}
        </code>
      </pre>
      <button id="copy-button">Copy</button>
    </div>
    <span id="copy-success">Code copied!</span>
  </div>

  </div>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
</body>
</html>
