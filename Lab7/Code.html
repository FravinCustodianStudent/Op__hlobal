<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="">
  <meta property="og:type" content="">
  <meta property="og:url" content="">
  <meta property="og:image" content="">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css">
  <link rel="manifest" href="site.webmanifest">
  <link rel="apple-touch-icon" href="icon.png">
  <!-- Place favicon.ico in the root directory -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/normalize.css">
  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/menu.css">
  <link href="../css/hover.css" rel="stylesheet" media="all">
  <link href="Lab.css" rel="stylesheet">
  <link rel='stylesheet' href='../box-shadows.css'>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
  />
  <meta name="theme-color" content="#fafafa">
</head>
<script src="../js/main.js"></script>
<body>
<div class="circlegradient" id="firstcircle"></div>
<div class="circlegradient" id="secondcircle"></div>
<div class="menu_g">
  <div class="menu_u">
    <map class="aa"><a href="../menu.html"><div class="gradieninputsqz hvr-grow" >
      <img src="../img/menu.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Меню</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href="purpose.html"><div class="gradieninputsqz hvr-grow" >
      <img src="../img/target.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Мета Роботи</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href="task3.html"><div class="gradieninputsqz hvr-grow" >
      <img src="../img/audit.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Умова задачі</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=Analize.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/search.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Аналіз задачі</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=Blockscheme.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/block-scheme-of-geometrical-shapes.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Блок-схема</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=Code.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/programming-code-signs.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Код програми</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=result.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/check-mark.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Результат<br>виконання </h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=proof.html> <div class="gradieninputsqz hvr-grow" >
      <img src="../img/approve.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Аналіз достовірності</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=conclusion.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/finalq.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Висновки</h2></div>
  </div>




</div>
<div class="mblock" id="generalqzzzz">
  <h1 id="maintextqqq">Код програми</h1>
  <div id="gradieninputsq" >
    <img src="../img/programming-code-signs.png" class="manuelement"></div>
  <div class="line" id="firstlineqq"></div>
  <div id="purposetext">
  <div class="container">
    <p class="language">C++</p>
    <div class="code-wrapper">
      <pre>
        <code id="code">
// Lab 7.0.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include < iostream>
#include < iomanip>
using namespace std;
enum Choice {
    First=1,
    Second=2
};
void Print_(int size) {
    for (int i = 0; i < size * 6; i++)
    {
        cout << "_";
    }
    cout <<"\n"<< endl;
}
void push_back(int*& arr, int& size, const int value) {
    int* newArray = new int[size + 1];
    for (int i = 0; i < size; i++)
    {
        newArray[i] = arr[i];
    }
    newArray[size] = value;
    size++;
    delete[] arr;
    arr = newArray;
}
void push_back(float*& arr, int& size, const float value) {
    float* newArray = new float[size + 1];
    for (int i = 0; i < size; i++)
    {
        newArray[i] = arr[i];
    }
    newArray[size] = value;
    size++;
    delete[] arr;
    arr = newArray;
}
void pop_back(float*& arr, int& size) {
    size--;
    float* newArray = new float[size + 1];
    for (int i = 0; i < size; i++)
    {
        newArray[i] = arr[i];
    }
    delete[] arr;//������� ������ ������
    arr = newArray;
}
float numberinput() {//Нам пртрібен алгоритм зручної перевіри на число, тобто ця функція перевіряє, чи ввів користувач число
    float x;
    while (!(std::cin >> x)) {
        std::cout << "Some of inputs were wrong, try again\n";
        std::cin.clear();
        fflush(stdin);
        std::cin.ignore(std::numeric_limits< std::streamsize>::max(), '\n');
    }
    return int(x);
}
void create_massive(int** firstmassive, const int& size) {
    int choice = 0, chance,rangemax, rangemin;
    std::cout << "Task : \nChoos type of massive creation:\n 1 - manual(input element of arrays by your keybord\n 2 - auto(massives will fill automaticaly by random numbers\n:";
    while (true) {
        choice = numberinput();
        if (choice == 1 || choice == 2)
        {
            break;
        }
        else {
            std::cout << "try again:";
        }
    }
    Choice choicz = static_cast< Choice>(choice);//Для вирішення проблеми магічних чисел
    switch (choicz) {
    case First:
        for (int i = 0; i < size; i++)
        {
            for (int i1 = 0; i1 < size; i1++)
            {
                std::cout << "Input element " << i + 1 << "of array" << std::endl;
                firstmassive[i][i1] = numberinput();
            }

        }
        break;
    case Second:
        std::cout << "Set begin of range" << std::endl;
        rangemin = numberinput();
        do {
            std::cout << "Set end of range" << std::endl;
            rangemax = numberinput();
        } while (rangemax < rangemin);
        for (int i = 0; i < size; i++)
        {
            for (int i1 = 0; i1 < size; i1++)
            {
                firstmassive[i][i1] = rand() % rangemax + rangemin;
            }

        }
        break;
    }
}
void create_massive(int** firstmassive, const int& m,const int&n) {
    int choice = 0, chance, rangemax, rangemin;
    std::cout << "Task : \nChoos type of massive creation:\n 1 - manual(input element of arrays by your keybord\n 2 - auto(massives will fill automaticaly by random numbers\n:";
    while (true) {
        choice = numberinput();
        if (choice == 1 || choice == 2)
        {
            break;
        }
        else {
            std::cout << "try again:";
        }
    }
    Choice choicz = static_cast< Choice>(choice);//Для вирішення проблеми магічних чисел
    switch (choicz) {
    case First:
        for (int i = 0; i < m; i++)
        {
            for (int i1 = 0; i1 < n; i1++)
            {
                std::cout << "Input element " << i + 1 << "of array" << std::endl;
                firstmassive[i][i1] = numberinput();
            }

        }
        break;
    case Second:
        std::cout << "Set begin of range" << std::endl;
        do {
            rangemin = numberinput();
        } while (rangemin < 0 );
        do {
            std::cout << "Set end of range" << std::endl;
            rangemax = numberinput();
        } while (rangemax < rangemin);
        for (int i = 0; i < m; i++)
        {
            for (int i1 = 0; i1 < n; i1++)
            {
                firstmassive[i][i1] = rand() % rangemax + rangemin;
            }

        }
        break;
    }
}
void task1() {
    int n;
    std::cout << "Input n: ";
    do {
        n = numberinput();
    } while (n < 3);
    int** matrix = new int*[n];//Двовимірний масив це, по факту, масив покажчіків на одновимірні масив
    for (int i = 0; i < n; i++)//Тому ми і створюємо ці масиви в масиві
    {
        matrix[i] = new int[n];
    }
    create_massive(matrix, n);
    cout << "\nOriginal matrix" << endl;
    Print_(n);
    for (int i = 0; i < n; i++)
    {
        cout << "| ";
        for (int i1 = 0; i1 < n; i1++)
        {

            cout << setw(5) << matrix[i][i1];
        }
        cout <<" |"<< endl;

    }
    Print_(n);
    int sum_same=0, perimeter_sum=0, dioganal_multiplication=1;
    //Заповнення данних за умовою
    for (int i = 0; i < n; i++)
    {
        for (int i1 = 0; i1 < n; i1++)
        {
            if (i != (n - 1) && matrix[i][i1]==matrix[i+1][i1])
            {
               sum_same += matrix[i][i1];
            }
            if (i1==(n-i-1))
            {
                dioganal_multiplication *= matrix[i][i1];
            }
            if (i==0 || i1==0||i1==(n-1))
            {
                perimeter_sum += matrix[i][i1];
            }



        }
    }
    Print_(n);
    float average_value;
    const int size_of_result_massive = 3;
    int result_massive[size_of_result_massive];
    result_massive[0] = sum_same;
    result_massive[1] = dioganal_multiplication;
    result_massive[2] = perimeter_sum;
    average_value = (sum_same + dioganal_multiplication + perimeter_sum)/3;
    for (int i = 0; i < n; i++)
    {
        for (int i1 = 0; i1 < n; i1++)
        {
            if (i != (n - 1) && matrix[i][i1] == matrix[i + 1][i1])
            {
                sum_same += matrix[i][i1]*2;
            }
            if (i1 == (n - i - 1))
            {
                dioganal_multiplication *= matrix[i][i1];
            }
            if (i == 0 || i1 == 0 || i1 == (n - 1))
            {
                perimeter_sum += matrix[i][i1];
            }



        }
    }
    int leftSide, rigthSide;
    if (n%2==0)
    {
        leftSide = n / 2 - 1;
        rigthSide = n / 2;
    }
    else {
        leftSide = (n - 1) / 2;
        rigthSide = leftSide;
    }

    for (int i = 0; i < n; i++)
    {
        if (n % 2 == 0 && i >= (n / 2) - 1)
        {
            leftSide--;
            rigthSide++;
        }
        else if (n % 2 != 0 && i >= (n - 1) / 2)
        {
            leftSide--;
            rigthSide++;
        }
        for (int i1 = 0; i1 < n; i1++)
        {

            if (n % 2 == 0)
            {

                if (i >= (n / 2) - 1)
                {
                    if (i1 > leftSide && i1 < rigthSide)
                    {
                        matrix[i][i1] = average_value;
                    }
                }
            }
            else {
                if (i >= (n -1) / 2)
                {
                    if (i1== (n - 1) / 2)
                    {
                        matrix[i][i1] = average_value;
                    }
                    else if (i1 > leftSide && i1 < rigthSide)
                    {
                        matrix[i][i1] = average_value;
                    }

                }
            }
        }



    }
    for (int i = 0; i < n; i++)
    {
        cout << "| ";
        for (int i1 = 0; i1 < n; i1++)
        {

            cout << setw(7) << matrix[i][i1];
        }
        cout << " |" << endl;

    }
    Print_(n);
    for (int i = 0; i < n; i++)
    {
        delete[] matrix[i];
    }
    delete[] matrix;
}
void task2() {
    int n,m;
    std::cout << "Input n: ";
    do {
        n = numberinput();
    } while (n < 2);
    m = n;// Для перемноження сматриць C X Потрібно щоб кількість рядків співпала з кількістью стовпців
    int** matrix = new int* [m];//Двовимірний масив це, по факту, масив покажчіків на одновимірні масив
    for (int i = 0; i < n; i++)//Тому ми і створюємо ці масиви в масиві
    {
        matrix[i] = new int[n];
    }
    create_massive(matrix, m, n);
    Print_(n);
    for (int i = 0; i < m; i++)
    {
        cout << "| ";
        for (int i1 = 0; i1 < n; i1++)
        {

            cout << setw(5) << matrix[i][i1];
        }
        cout << " |" << endl;

    }
    Print_(n);
    int* x = new int[m];
    int* C = new int[n];
    int* S = new int[n];
    for (int i = 0; i < n; i++)//Для обрахунку+= в змінній повинно щось бути крім мусору компілятора
    {
        S[i] = 0;
    }
    int result_x = 0, result_c = 0;
    for (int i = 0; i < m; i++)
    {
        result_x = matrix[i][0];
        for (int i1 = 0; i1 < n; i1++)
        {
            if (result_x>matrix[i][i1])
            {
                result_x = matrix[i][i1];
            }
            S[i] += matrix[i][i1];

        }
        x[i] = result_x;
    }
    for (int i = 0; i < n; i++)//Задаємо вартість
    {
        C[i] = rand() % 100;
    }
    cout << "C =(";
    for (int i = 0; i < n; i++)
    {
        cout << setw(4) << C[i];
    }
    cout << " ) \n\n\nX\n_" << endl;
    for (int i = 0; i < m; i++)
    {
        cout << x[i] << endl;
    }
    cout << "_\n" << endl;

    for (int i = 0; i < n; i++)
    {

    }
    for (int i = 0; i < n; i++)
    {
        delete[] matrix[i];
    }
    int P=0;
    for (int i = 0; i < n; i++)
    {
        P += C[i] * x[i];
    }
    cout << "S: {";
    for (int i = 0; i < n; i++)
    {
        cout << setw(5) << S[i];
    }
    cout << "}\nP= " << P;
    delete[] x;
    delete[] C;
    delete[] S;
}
int main(){
    srand(time(NULL));
    Choice choice;// Enum - єлементи для вирішення проблеми магічних чисел
    int Ch;
    setlocale(LC_ALL, "Rus");
    std::cout << "\n----START----\nLab 7. Var23. Student Fesak Andrii IPZ-12\nWelcome to see recurent function in C++\n--------" << std::endl;
    //Логічно, що програма повинна виконуватись поки користувач цього хоче тому while(true)
    while (true) {
        std::cout << "\nChoose the task by press (1)(2) on your keyboard:  ";
        Ch = numberinput();
        choice =  static_cast< Choice>(Ch);
        switch (choice) {
        case First:
            system("cls");
            task1();
            break;
        case Second:
            system("cls");
            task2();
            break;
        }
        //Потрібен метод виходу з програми
        std::cout << "\nDo you want to continue?\n1 - No\nAnything else - Yes\nYour answer: ";
        std::cin >> Ch;
        choice = static_cast< Choice>(Ch);
        if (choice == First)
        {
            break;
            system("cls");
        }
    }

}
        </code>
      </pre>
      <button id="copy-button">Copy</button>
    </div>
    <span id="copy-success">Code copied!</span>
  </div>

  </div>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
</body>
</html>
