<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="">
  <meta property="og:type" content="">
  <meta property="og:url" content="">
  <meta property="og:image" content="">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css">
  <link rel="manifest" href="site.webmanifest">
  <link rel="apple-touch-icon" href="icon.png">
  <!-- Place favicon.ico in the root directory -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/normalize.css">
  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/menu.css">
  <link href="../css/hover.css" rel="stylesheet" media="all">
  <link href="Lab.css" rel="stylesheet">
  <link rel='stylesheet' href='../box-shadows.css'>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
  />
  <meta name="theme-color" content="#fafafa">
</head>
<script src="../js/main.js"></script>
<body>
<div class="circlegradient" id="firstcircle"></div>
<div class="circlegradient" id="secondcircle"></div>
<div class="menu_g">
  <div class="menu_u">
    <map class="aa"><a href="../menu.html"><div class="gradieninputsqz hvr-grow" >
      <img src="../img/menu.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Меню</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href="purpose.html"><div class="gradieninputsqz hvr-grow" >
      <img src="../img/target.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Мета Роботи</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href="task3.html"><div class="gradieninputsqz hvr-grow" >
      <img src="../img/audit.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Умова задачі</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=Analize.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/search.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Аналіз задачі</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=Blockscheme.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/block-scheme-of-geometrical-shapes.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Блок-схема</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=Code.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/programming-code-signs.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Код програми</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=result.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/check-mark.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Результат<br>виконання </h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=proof.html> <div class="gradieninputsqz hvr-grow" >
      <img src="../img/approve.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Аналіз достовірності</h2></div>
  </div>
  <div class="menu_u">
    <map class="aa"><a href=conclusion.html><div class="gradieninputsqz hvr-grow" >
      <img src="../img/finalq.png" class="manuelementq">
    </div></a></map>
    <div class="hovertext"  ><h2 class="ht">Висновки</h2></div>
  </div>




</div>
<div class="mblock" id="generalqzzzz">
  <h1 id="maintextqqq">Код програми</h1>
  <div id="gradieninputsq" >
    <img src="../img/programming-code-signs.png" class="manuelement"></div>
  <div class="line" id="firstlineqq"></div>
  <div id="purposetext">
  <div class="container">
    <p class="language">C++</p>
    <div class="code-wrapper">
      <pre>
        <code id="code">

#include < iostream>
#include < fstream>
#include < stdio.h>
#include < mutex>
#include < thread>
#include< iomanip>
using namespace std;

class MyString
{
public:

	//конструктор без парамтрів
	MyString()
	{
		str = nullptr;
		length = 0;
	}

	//конструктор з параметрами, під час створення об'єкта класу необхідно переробити рядок який він зберігатиме
	MyString(const char* str)
	{

		length = strlen(str);// функція strlen отримує кількість символів у рядку, який ми передаємо в об'єкт

		//виділяємо пам'ять для динамічного масиву де зберігатиметься наш рядок
		this->str = new char[length + 1];

		//копіюємо символи рядка до масиву нашого класу
		for (int i = 0; i < length; i++)
		{
			this->str[i] = str[i];
		}


		//закриваємо рядок термінуючим нулем
		this->str[length] = '\0';

	}
	// Деструктор, що відповідає за звільнення ресурсів зайнятих об'єктом, викликається при знищенні об'єкта класу
	~MyString()
	{

		delete[] this->str;
	}

	// Конструктор копіювання, необхідний для створення точної копії об'єкта класу, але в іншій області пам'яті
	MyString(const MyString& other)
	{
		length = strlen(other.str);
		this->str = new char[length + 1];

		for (int i = 0; i < length; i++)
		{
			this->str[i] = other.str[i];
		}

		this->str[length] = '\0';
	}

	// перезавантажений оператор привласнення, що викликається коли необхідно присвоїти значення одного об'єкта іншому
	MyString& operator =(const MyString& other)
	{
		if (this->str != nullptr)
		{
			delete[] str;
		}

		length = strlen(other.str);
		this->str = new char[length + 1];

		for (int i = 0; i < length; i++)
		{
			this->str[i] = other.str[i];
		}

		this->str[length] = '\0';

		return *this;

	}

	//перезавантажений оператор складання, у поточній реалізації класу String необхідний для конкатенації рядків
	MyString operator+(const MyString& other)
	{
		MyString newStr;

		int thisLength = strlen(this->str);
		int otherLength = strlen(other.str);

		newStr.length = thisLength + otherLength;

		newStr.str = new char[thisLength + otherLength + 1];

		int i = 0;
		for (; i < thisLength; i++)
		{
			newStr.str[i] = this->str[i];
		}

		for (int j = 0; j < otherLength; j++, i++)
		{
			newStr.str[i] = other.str[j];
		}

		newStr.str[thisLength + otherLength] = '\0';

		return newStr;
	}
	MyString operator<<(const MyString& other) {
		cout << other.str;
	}
	MyString GetStr() {
		return str;
	}
	void Print()
	{
		cout << str;
	}

	int Length()
	{
		return length;
	}
	bool operator ==(const MyString& other)
	{
		if (this->length != other.length)
		{
			return false;
		}

		for (int i = 0; i < this->length; i++)
		{
			if (this->str[i] != other.str[i])
			{
				return false;
			}
		}
		return true;
	}

	bool operator !=(const MyString& other)
	{
		return !(this->operator==(other));
	}

	char& operator [](int index)
	{
		return this->str[index];
	}

	MyString(MyString&& other)
	{
		this->length = other.length;
		this->str = other.str;
		other.str = nullptr;
	}
	friend ostream;
	char* str;
private:

	int length;
};

ostream& operator <<(ostream& os, MyString& stri) {

	os << stri.str;
	return os;
}
istream& operator>>(istream& is, MyString& st) {
	is >> st.str;
	return is;
}
void Print_(const int& amount);
float NumberInput();
enum Choice {
	First = 1,
	Second = 2,
	Third = 3,
	Fourth = 4,
	Fifth = 5,
	Sixth = 6,
	EndStatus = 222
};

Choice choice;
template< typename T>
class List
{
public:
	List();
	~List();

	//удаление первого элемента в списке
	void pop_front();

	//добавление элемента в конец списка
	void push_back(T data);

	// очистить список
	void clear();

	// получить количество елементов в списке
	int GetSize() { return Size; }

	// перегруженный оператор []
	T& operator[](const int index);

	//добавление элемента в начало списка
	void push_front(T data);

	//добавление элемента в список по указанному индексу
	void insert(T data, int index);

	//удаление элемента в списке по указанному индексу
	void removeAt(int index);

	//удаление последнего элемента в списке
	void pop_back();

private:


	template< typename T>
	class Node
	{
	public:
		Node* pNext;
		T data;

		Node(T data = T(), Node* pNext = nullptr)
		{
			this->data = data;
			this->pNext = pNext;
		}
	};
	int Size;
	Node< T>* head;
};


template< typename T>
List< T>::List()
{
	Size = 0;
	head = nullptr;
}


template< typename T>
List< T>::~List()
{
	clear();
}


template< typename T>
void List< T>::pop_front()
{
	Node< T>* temp = head;

	head = head->pNext;

	delete temp;

	Size--;

}

template< typename T>
void List< T>::push_back(T data)
{
	if (head == nullptr)
	{
		head = new Node< T>(data);
	}
	else
	{
		Node< T>* current = this->head;

		while (current->pNext != nullptr)
		{
			current = current->pNext;
		}
		current->pNext = new Node< T>(data);

	}

	Size++;
}

template< typename T>
void List< T>::clear()
{
	while (Size)
	{
		pop_front();
	}
}


template< typename T>
T& List< T>::operator[](const int index)
{
	int counter = 0;

	Node< T>* current = this->head;

	while (current != nullptr)
	{
		if (counter == index)
		{
			return current->data;
		}
		current = current->pNext;
		counter++;
	}
}
class Mstr:public string
{
};


template< typename T>
void List< T>::push_front(T data)
{
	head = new Node< T>(data, head);
	Size++;
}

template< typename T>
void List< T>::insert(T data, int index)
{

	if (index == 0)
	{
		push_front(data);
	}
	else
	{
		Node< T>* previous = this->head;

		for (int i = 0; i < index - 1; i++)
		{
			previous = previous->pNext;
		}

		Node< T>* newNode = new Node< T>(data, previous->pNext);

		previous->pNext = newNode;

		Size++;
	}





}

template< typename T>
void List< T>::removeAt(int index)
{
	if (index == 0)
	{
		pop_front();
	}
	else
	{
		Node< T>* previous = this->head;
		for (int i = 0; i < index - 1; i++)
		{
			previous = previous->pNext;
		}


		Node< T>* toDelete = previous->pNext;

		previous->pNext = toDelete->pNext;

		delete toDelete;

		Size--;
	}

}

template< typename T>
void List< T>::pop_back()
{
	removeAt(Size - 1);
}
struct Student {
	enum Faculty
	{
		NFaculty = 0,
		FIT = 1,
		Cybernetic = 2

	};
	string name;
	int stipedndia;
	int mark;
	int faculty;
	int cource;
	int group;

	Student() {
		this->mark = NULL;
		this->faculty = NULL;
		this->stipedndia = NULL;
		this->cource = NULL;
		this->group = NULL;
	}
	Student(string name, int mark, int choice, int cource, int group) {
		this->name = name;
		this->mark = mark;
		this->stipedndia = NULL;
		this->cource = cource;
		this->group = group;
		this->faculty = static_cast< Faculty>(choice);

	}
	Student(string name, int mark, int stipendia, int choice, int cource, int group) :Student(name, mark, choice, cource, group) {
		this->stipedndia = stipendia;
	}
	void Show_info() {
		cout << "|Name: " << setw(5)<< name<< setw(12) << " |Mark:" << setw(5) << mark << setw(5) << setw(5) << " |Cource " << cource << setw(5) << " |Group " << group << " |Faculty: " << setw(9);
		if (faculty == 1)
		{
			cout << "FIT        " << setw(9);
		}
		else {
			cout << "Cybernetic " << setw(9);
		}

		cout << "|Stypendia: " << setw(5) << stipedndia << " |" << endl;
	}
};
ostream& operator<<(ostream& os,Student& st) {
	os << st.name << " " << st.mark << " " << st.cource << " " << st.group << " " << st.faculty << " " << st.stipedndia;
	return os;
}
istream& operator>>(istream& is,Student& st) {
	is >> st.name >> st.mark >> st.cource >> st.group >> st.faculty >> st >> st.stipedndia;
	return is;
}
void CreateMassiveOfStudent(List< Student>& Group, List< string>& Names)
{
	for (int i1 = 1; i1 < 3; i1++)
	{
		for (int i2 = 1; i2 < 5; i2++)
		{
			for (int i = 1; i < 5; i++)
			{
				for (int i = 0; i < 4; i++)
				{
					int chance_on_stypendia = rand() % 100;
					if (chance_on_stypendia < 50)
					{
						int mark, stipendia;
						int name;
						mark = 4 + rand() % 2;
						name = rand() % 11;
						stipendia = rand() % 200 + 50;

						string nameofst = Names[name];
						Student withsipendia = { nameofst,mark,stipendia,i1,i2,i };
						Group.push_back(withsipendia);
					}
					else {
						int mark;
						int name;
						mark = 2 + rand() % 2;
						name = rand() % 11;
						string nameofst = Names[name];
						Student withoutStipendia = { nameofst,mark,i1,i2,i };
						Group.push_back(withoutStipendia);
					}

				}
			}

		}
	}
}
void inputData(List< Student>& Group) {
	ofstream ofs;
	ofs.open("SecondTask.txt", std::ofstream::out | std::ofstream::trunc);
	ofs.close();
	ofstream m;
	m.open("SecondTask.txt", ofstream::app);
	if (!m.is_open())
	{
		cout << "Error" << endl;
	}
	else {
		for (size_t i = 0; i < Group.GetSize(); i++)
		{
			Student s;
			s = Group[i];
			m.write((char*)&s, sizeof(Student));
		}

	}
	m.close();
}
void stask() {
	fstream fount;
	fount.open("1.txt", ofstream::app);
	if (!fount.is_open())
	{
		cout << "Error" << endl;
	}
	else {
		fount << "qwerty" << endl;
		fount << "zxcvb" << endl;
		fount << "qwerty" << endl;
		fount << "qwesad" << endl;
		fount << "xcvbds" << endl;
	}
	fount.close();
}
void task1() {
	fstream fount;
	thread t1(stask);
	t1.join();
	fount.open("2.txt", ofstream::app);
	if (!fount.is_open())
	{
		cout << "Error" << endl;
	}
	else {
		fount << "qwerty" << endl;
		fount << "qwesasdd" << endl;
		fount << "qwerty" << endl;
		fount << "qwesad" << endl;
		fount << "vvvvssss" << endl;
	}
	fount.close();
	fstream z;
	z.open("2.txt", ofstream::out || ofstream::app);
	List< MyString> words1;
	List< MyString> words2;
	MyString str = "str";
	if (!z.is_open())
	{
		cout << "Error" << endl;
	}
	else {
		while (!z.eof())
		{
			str = "";
			char line[20];
			z >> line;
			MyString word = MyString(line);
			words1.push_back(word);
		}
	}
	z.close();
	fstream z1;
	z1.open("1.txt", ofstream::out || ofstream::app);
	if (!z1.is_open())
	{
		cout << "Error" << endl;
	}
	else {
		while (!z1.eof())
		{
			str = "";
			char line[20];
			z1 >> line;
			MyString word = MyString(line);
			words2.push_back(word);
		}
	}
	z1.close();
	fstream x1;
	x1.open("A.txt",ofstream::app);
	x1 << "Task a" << endl;
		int counter;
		for (size_t i = 0; i < words1.GetSize(); i++)
		{
			MyString text = words1[i];
			x1 << text << endl;
		}
		x1 << "______________" << endl;
	x1.close();
	List< MyString> wordsTaskA;
	List< MyString> wordsTaskB;
	List< MyString> wordsTaskC;
	fstream task;
	task.open("B.txt", ofstream::app);
	if (!task.is_open())
	{
		cout << "Error2" << endl;
	}
	else {
		MyString repeteTwice;
		for (size_t i = 0; i < words1.GetSize(); i++)
		{
			int counter = 0;
			for (size_t i1 = 0; i1 < words2.GetSize(); i1++)
			{

				if (words1[i]==words2[i1])
				{
					wordsTaskB.push_back(words1[i]);
					repeteTwice = words1[i];
					counter++;
				}
				if (repeteTwice==words2[i1])
				{
					counter++;
				}
			}
			if (counter==2)
			{
				wordsTaskC.push_back(repeteTwice);

			}
			else {
				repeteTwice = "0";
			}
		}
		task << "Task B" << endl;
		task << "_________________" << endl;
		for (size_t i = 0; i < wordsTaskB.GetSize(); i++)
		{
			MyString text = wordsTaskB[i];
			task << text << endl;
		}
		task.close();
		fstream taskC;
		taskC.open("C.txt", fstream::app);
		taskC << "Task C\n____________" << endl;
		for (size_t i = 0; i < wordsTaskC.GetSize(); i++)
		{
			MyString text = wordsTaskC[i];
			taskC << text << endl;
		}
	}
}
void CreateNewStudent(Student &student) {
	Student st;
	cout << "Input name" << endl;
	string name;
	cin >> name;
	int mark, faculty, cource, group, stipedndia;
	cout << "Input Mark" << endl;
	do
	{
		mark = NumberInput();
	} while (mark < 3 || mark > 5);
	cout << "Input Faculty" << endl;
	while (true)
	{
		faculty = NumberInput();
		if (faculty==1|| faculty==2)
		{
			break;
		}
	}
	cout << "Input Cource" << endl;
	do
	{
		cource = NumberInput();
	} while (cource < 1 || cource > 4);
	cout << "Input Group" << endl;
	do
	{
		group = NumberInput();
	} while (group < 1 || group > 4);
	cout << "Input stipedndia" << endl;
	do
	{
		stipedndia = NumberInput();
	} while (stipedndia < 0 && stipedndia > 1500);
	student.mark = mark;
	student.faculty = faculty;
	student.cource = cource;
	student.name = name;
	student.group = group;
	student.stipedndia = stipedndia;
}
void inputNewData(List< Student>& Group) {
	Student NewData;
	CreateNewStudent(NewData);
	ofstream m;
	m.open("SecondTask.txt", ofstream::app);
	if (!m.is_open())
	{
		cout << "Error" << endl;
	}
	else {

			m.write((char*)&NewData, sizeof(Student));
	}
	m.close();
	Group.push_back(NewData);
	inputData(Group);
}
void ChangeSelectedData(List< Student>& Group) {
	int Ch;
	cout << "Select id of data" << endl;
	do
	{
		Ch = NumberInput();
	} while (Ch<0|| Ch>(Group.GetSize()-1));
	cout << "Input name" << endl;
	string name;
	cin >> name;
	int mark, faculty, cource, group, stipedndia;
	cout << "Input Mark" << endl;
	do
	{
		mark = NumberInput();
	} while (mark < 3 || mark > 5);
	cout << "Input Faculty" << endl;
	while (true)
	{
		faculty = NumberInput();
		if (faculty == 1 || faculty == 2)
		{
			break;
		}
	}
	cout << "Input Cource" << endl;
	do
	{
		cource = NumberInput();
	} while (cource < 1 || cource > 4);
	cout << "Input Group" << endl;
	do
	{
		group = NumberInput();
	} while (group < 1 || group > 4);
	cout << "Input stipedndia" << endl;
	do
	{
		stipedndia = NumberInput();
	} while (stipedndia < 0 && stipedndia > 1500);
	Group[Ch].mark = mark;
	Group[Ch].faculty = faculty;
	Group[Ch].cource = cource;
	Group[Ch].name = name;
	Group[Ch].group = group;
	Group[Ch].stipedndia = stipedndia;
	inputData(Group);
}
void DeleteSelectedData(List< Student>& Group) {
	int Ch;
	cout << "Select id of data" << endl;
	do
	{
		Ch = NumberInput();
	} while (Ch<0 || Ch>(Group.GetSize() - 1));
	Group.removeAt(Ch);
	inputData(Group);
}
void task4(List< Student>& Group) {
	Print_(60);
	float averageMark = 0;
	float AmountOfStudentWithStipendia = 0;
	for (size_t i = 0; i < Group.GetSize(); i++)
	{

		if (Group[i].stipedndia != NULL)
		{
			Group[i].Show_info();
			AmountOfStudentWithStipendia++;
			averageMark += Group[i].mark;
		}
	}
	cout << "Averege mark: " << averageMark / AmountOfStudentWithStipendia << endl;
	Print_(60);
}
void task5(List< Student>& Group) {
	Print_(60);
	int FitProblems = 0, CyberneticProbelems = 0;
	for (size_t i = 0; i < Group.GetSize(); i++)
	{
		if (Group[i].mark == 2 && Group[i].faculty == 1)
		{
			FitProblems++;
		}
		else if (Group[i].mark == 2 && Group[i].faculty == 2)
		{
			CyberneticProbelems++;
		}
	}
	cout << "FIT = " << FitProblems << endl;
	cout << "Cybernetic = " << CyberneticProbelems << endl;
	if (FitProblems > CyberneticProbelems)
	{
		cout << "Cybernetic has less flunkey than FIT" << endl;
	}
	else {
		cout << "FIT has less flunkeys than Cybernetic" << endl;
	}
	Print_(60);
}
void task6(List< Student>& Group) {
	Print_(60);
	int FITAchivments = 0, CyberneticAchivments = 0;
	for (size_t i = 0; i < Group.GetSize(); i++)
	{
		if (Group[i].mark == 5 && Group[i].faculty == 1)
		{
			FITAchivments++;
		}
		else if (Group[i].mark == 5 && Group[i].faculty == 2)
		{
			CyberneticAchivments++;
		}
	}
	cout << "FIT = " << FITAchivments << endl;
	cout << "Cybernetic = " << CyberneticAchivments << endl;
	if (FITAchivments > CyberneticAchivments)
	{
		cout << "FIT has more excellent student than Cybernetic" << endl;
	}
	else {
		cout << "Cybernetic has more excellent student than FIT" << endl;
	}
	Print_(60);
}
void task2(List< Student> &Group) {
	List< Student> OutputStudents;
	int Ch;
	inputData(Group);
	while (true)
	{
		Print_(60);
		cout << "1.add new data\n2.change selected data\n3.delete selected data\n4.students with stipendia\n5.Faculty with the less amount student with bad marks\n6.The best faculty" << endl;
		Print_(60);
		Ch = NumberInput();
		choice = static_cast< Choice>(Ch);
		switch (choice)
		{
		case First:
			inputNewData(Group);
			break;
		case Second:
			ChangeSelectedData(Group);
			break;
		case Third:
			DeleteSelectedData(Group);
			break;
		case Fourth:
			task4(Group);
			break;
		case Fifth:
			task5(Group);
			break;
		case Sixth:
			task6(Group);
			break;
		default:
			std::cout << "\nDo you want to continue?\n1 - No\nAnything else - Yes\nYour answer: ";
			std::cin >> Ch;
			choice = static_cast< Choice>(Ch);
			if (choice == First)
			{
				choice = EndStatus;
			}
			break;
		}
		if (choice == EndStatus) break;
	}
	ifstream fin;
	fin.open("SecondTask.txt");
	if (!fin.is_open())
	{
		cout << "Error12" << endl;
	}
	else {

			Student st;
			while (fin.read((char*)&st, sizeof(Student)))
			{
				st.Show_info();
			}

	}
	fin.close();
}
int main()
{
	srand(time(NULL));
    setlocale(LC_ALL, "ru");
	List< Student> Group;
	List< string> Names;
	Names.push_back("Ivan");
	Names.push_back("Rodslav");
	Names.push_back("Volodimir");
	Names.push_back("Albert");
	Names.push_back("Arthur");
	Names.push_back("Vilgeim");
	Names.push_back("Ada");
	Names.push_back("Pavlo");
	Names.push_back("Magda");
	Names.push_back("Darina");
	Names.push_back("Julia");
	Names.push_back("Ustina");
	CreateMassiveOfStudent(Group, Names);
	int Ch;
	std::cout << "\n----START----\nLab 11. Var23. Student Fesak Andrii IPZ-12\nWelcome to see recurent function in C++\n--------" << std::endl;
	//Логічно, що програма повинна виконуватись поки користувач цього хоче тому while(true)
	while (true) {
		Print_(60);
		std::cout << "\nSelect item by press (1)(2) on your keyboard:\n1. task1\n2.task 2 \nAnything else. - Exit" << endl;
		Print_(60);
		Ch = NumberInput();
		choice = static_cast< Choice>(Ch);
		switch (choice) {
		case First:
			system("cls");
			task1();
			break;
		case Second:
			system("cls");
			task2(Group);
			break;
		default:
			//Потрібен метод виходу з програми
			std::cout << "\nDo you want to continue?\n1 - No\nAnything else - Yes\nYour answer: ";
			std::cin >> Ch;
			choice = static_cast< Choice>(Ch);
			if (choice == First)
			{
				choice = EndStatus;
			}
			break;
		}
		//Потрібен метод виходу з програми
		if (choice == EndStatus) break;
	}
}
float NumberInput() {
	float x;
	while (!(std::cin >> x)) {
		std::cout << "Some of inputs were wrong, try again\n";
		std::cin.clear();
		fflush(stdin);
		std::cin.ignore(std::numeric_limits< std::streamsize>::max(), '\n');
	}
	return x;
}
void Print_(const int& amount) {
	for (int i = 0; i < amount; i++)
	{
		std::cout << "_";
	}
	std::cout << "\n" << endl;
}

        </code>
      </pre>
      <button id="copy-button">Copy</button>
    </div>
    <span id="copy-success">Code copied!</span>
  </div>

  </div>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
</body>
</html>
